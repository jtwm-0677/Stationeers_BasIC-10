using System;
using System.Collections.Generic;
using System.Linq;
using BasicToMips.UI.VisualScripting.Canvas;
using BasicToMips.UI.VisualScripting.CodeGen;
using BasicToMips.UI.VisualScripting.Nodes;

namespace BasicToMips.UI.VisualScripting.Services
{
    /// <summary>
    /// Manages bidirectional highlighting synchronization between the visual canvas and code panel
    /// - When a node is selected on canvas, highlights corresponding code lines
    /// - When a code line is clicked, selects corresponding node on canvas
    /// </summary>
    public class HighlightSyncService
    {
        private readonly CodePanel _codePanel;
        private readonly VisualCanvas _canvas;
        private SourceMap? _sourceMap;

        /// <summary>
        /// Creates a new highlight sync service
        /// </summary>
        /// <param name="codePanel">The code panel to sync with</param>
        /// <param name="canvas">The visual canvas to sync with</param>
        public HighlightSyncService(CodePanel codePanel, VisualCanvas canvas)
        {
            _codePanel = codePanel;
            _canvas = canvas;

            // Subscribe to selection changes on canvas
            _canvas.SelectionChanged += Canvas_SelectionChanged;

            // Subscribe to line clicks in code panel
            _codePanel.LineClicked += CodePanel_LineClicked;
        }

        /// <summary>
        /// Update the source map used for synchronization
        /// </summary>
        /// <param name="sourceMap">The new source map from code generation</param>
        public void UpdateSourceMap(SourceMap? sourceMap)
        {
            _sourceMap = sourceMap;

            // Clear any existing highlights when source map changes
            _codePanel.ClearHighlights();
        }

        /// <summary>
        /// Handle selection changes on the canvas
        /// </summary>
        private void Canvas_SelectionChanged(object? sender, SelectionChangedEventArgs e)
        {
            if (_sourceMap == null)
            {
                _codePanel.ClearHighlights();
                return;
            }

            // Get the currently selected nodes
            var selectedNodes = _canvas.Selection.SelectedItems.OfType<NodeBase>().ToList();

            if (selectedNodes.Count == 0)
            {
                _codePanel.ClearHighlights();
                return;
            }

            // Collect all lines generated by selected nodes
            var linesToHighlight = new HashSet<int>();

            foreach (var node in selectedNodes)
            {
                var lines = _sourceMap.GetLinesForNode(node.Id);
                foreach (var line in lines)
                {
                    linesToHighlight.Add(line);
                }
            }

            if (linesToHighlight.Count > 0)
            {
                // Highlight the lines
                _codePanel.HighlightLines(linesToHighlight.ToArray());

                // Scroll to the first line of the first selected node
                var firstNode = selectedNodes[0];
                var firstLines = _sourceMap.GetLinesForNode(firstNode.Id);
                if (firstLines.Count > 0)
                {
                    _codePanel.ScrollToLine(firstLines.Min());
                }
            }
            else
            {
                _codePanel.ClearHighlights();
            }
        }

        /// <summary>
        /// Handle line clicks in the code panel
        /// </summary>
        private void CodePanel_LineClicked(object? sender, LineClickedEventArgs e)
        {
            if (_sourceMap == null)
                return;

            // Find the node that generated this line
            var nodeId = _sourceMap.GetNodeForLine(e.LineNumber);
            if (nodeId == Guid.Empty)
                return;

            // Find the node on the canvas
            // NOTE: This requires the canvas to expose its nodes collection
            // For now, we'll use the selection manager to find the node
            // This will be implemented when we integrate with the full canvas

            // TODO: Implement node selection from line click
            // This requires access to the canvas's node collection
            // For now, just store the selected node ID in the view model
            _codePanel.ViewModel.SelectedNodeId = nodeId;
        }

        /// <summary>
        /// Manually highlight lines for a specific node
        /// </summary>
        /// <param name="nodeId">The node ID to highlight</param>
        public void HighlightNode(Guid nodeId)
        {
            if (_sourceMap == null)
            {
                _codePanel.ClearHighlights();
                return;
            }

            var lines = _sourceMap.GetLinesForNode(nodeId);
            if (lines.Count > 0)
            {
                _codePanel.HighlightLines(lines.ToArray());
                _codePanel.ScrollToLine(lines.Min());
            }
            else
            {
                _codePanel.ClearHighlights();
            }
        }

        /// <summary>
        /// Clear all highlights
        /// </summary>
        public void ClearHighlights()
        {
            _codePanel.ClearHighlights();
        }

        /// <summary>
        /// Get the lines associated with a node
        /// </summary>
        /// <param name="nodeId">The node ID</param>
        /// <returns>List of line numbers (1-based), or empty list if not found</returns>
        public List<int> GetLinesForNode(Guid nodeId)
        {
            return _sourceMap?.GetLinesForNode(nodeId) ?? new List<int>();
        }

        /// <summary>
        /// Get the node associated with a line
        /// </summary>
        /// <param name="lineNumber">The line number (1-based)</param>
        /// <returns>Node ID, or Guid.Empty if not found</returns>
        public Guid GetNodeForLine(int lineNumber)
        {
            return _sourceMap?.GetNodeForLine(lineNumber) ?? Guid.Empty;
        }

        /// <summary>
        /// Dispose of event subscriptions
        /// </summary>
        public void Dispose()
        {
            _canvas.SelectionChanged -= Canvas_SelectionChanged;
            _codePanel.LineClicked -= CodePanel_LineClicked;
        }
    }
}
