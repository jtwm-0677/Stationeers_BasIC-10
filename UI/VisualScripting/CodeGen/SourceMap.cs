using System;
using System.Collections.Generic;
using System.Linq;

namespace BasicToMips.UI.VisualScripting.CodeGen
{
    /// <summary>
    /// Maps generated code lines to visual nodes and vice versa
    /// Used for bidirectional highlight sync between code and visual graph
    /// </summary>
    public class SourceMap
    {
        #region Properties

        /// <summary>
        /// Maps node IDs to the line numbers they generated
        /// A node can generate multiple lines
        /// </summary>
        public Dictionary<Guid, List<int>> NodeToLines { get; } = new();

        /// <summary>
        /// Maps line numbers to the node that generated them
        /// Each line comes from exactly one node
        /// </summary>
        public Dictionary<int, Guid> LineToNode { get; } = new();

        /// <summary>
        /// Maps line numbers to their content (for debugging)
        /// </summary>
        public Dictionary<int, string> LineContent { get; } = new();

        #endregion

        #region Methods

        /// <summary>
        /// Add a mapping for a single line generated by a node
        /// </summary>
        /// <param name="nodeId">The node that generated this line</param>
        /// <param name="lineNumber">The line number (1-based)</param>
        /// <param name="content">The line content</param>
        public void AddMapping(Guid nodeId, int lineNumber, string content)
        {
            // Add to node-to-lines mapping
            if (!NodeToLines.ContainsKey(nodeId))
            {
                NodeToLines[nodeId] = new List<int>();
            }
            NodeToLines[nodeId].Add(lineNumber);

            // Add to line-to-node mapping
            LineToNode[lineNumber] = nodeId;

            // Store line content
            LineContent[lineNumber] = content;
        }

        /// <summary>
        /// Add mappings for multiple lines generated by a node
        /// </summary>
        /// <param name="nodeId">The node that generated these lines</param>
        /// <param name="startLine">Starting line number (1-based)</param>
        /// <param name="lines">The lines of content</param>
        public void AddMappings(Guid nodeId, int startLine, params string[] lines)
        {
            for (int i = 0; i < lines.Length; i++)
            {
                AddMapping(nodeId, startLine + i, lines[i]);
            }
        }

        /// <summary>
        /// Get all line numbers generated by a specific node
        /// </summary>
        /// <param name="nodeId">The node ID</param>
        /// <returns>List of line numbers, or empty list if node not found</returns>
        public List<int> GetLinesForNode(Guid nodeId)
        {
            return NodeToLines.TryGetValue(nodeId, out var lines) ? lines : new List<int>();
        }

        /// <summary>
        /// Get the node that generated a specific line
        /// </summary>
        /// <param name="lineNumber">The line number (1-based)</param>
        /// <returns>Node ID, or Guid.Empty if line not found</returns>
        public Guid GetNodeForLine(int lineNumber)
        {
            return LineToNode.TryGetValue(lineNumber, out var nodeId) ? nodeId : Guid.Empty;
        }

        /// <summary>
        /// Get the content of a specific line
        /// </summary>
        /// <param name="lineNumber">The line number (1-based)</param>
        /// <returns>Line content, or empty string if line not found</returns>
        public string GetLineContent(int lineNumber)
        {
            return LineContent.TryGetValue(lineNumber, out var content) ? content : string.Empty;
        }

        /// <summary>
        /// Get the line range for a node (min and max line numbers)
        /// </summary>
        /// <param name="nodeId">The node ID</param>
        /// <returns>Tuple of (minLine, maxLine), or (0, 0) if node not found</returns>
        public (int minLine, int maxLine) GetLineRangeForNode(Guid nodeId)
        {
            var lines = GetLinesForNode(nodeId);
            if (lines.Count == 0)
                return (0, 0);

            return (lines.Min(), lines.Max());
        }

        /// <summary>
        /// Clear all mappings
        /// </summary>
        public void Clear()
        {
            NodeToLines.Clear();
            LineToNode.Clear();
            LineContent.Clear();
        }

        /// <summary>
        /// Get total number of mapped lines
        /// </summary>
        public int TotalLines => LineToNode.Count;

        #endregion
    }
}
