using System.Text;
using BasicToMips.AST;

namespace BasicToMips.CodeGen;

public class MipsGenerator
{
    private readonly StringBuilder _output = new();
    private readonly Dictionary<string, int> _variables = new();
    private readonly Dictionary<string, int[]> _arrays = new();
    private readonly Dictionary<int, string> _lineLabels = new();
    private readonly Dictionary<string, string> _labelMap = new();
    private readonly Dictionary<string, string> _aliases = new();
    private readonly Dictionary<string, double> _defines = new();
    private readonly Stack<string> _loopEndLabels = new();
    private readonly Stack<string> _loopStartLabels = new();
    private readonly Stack<string> _gosubStack = new();

    private int _nextRegister = 0;
    private int _nextLabel = 0;
    private int _stackPointer = 0;
    private const int MaxRegisters = 14; // r0-r13 available for variables
    private const int TempRegister = 14; // r14 for temp operations
    private const int TempRegister2 = 15; // r15 for second temp operations
    // Note: IC10 uses 'sp' and 'ra' as named registers, not numbered

    public string Generate(ProgramNode program)
    {
        // First pass: collect all line labels and named labels
        foreach (var (lineNum, index) in program.LineNumberMap)
        {
            _lineLabels[lineNum] = $"line_{lineNum}";
        }

        // Collect named labels
        foreach (var stmt in program.Statements)
        {
            if (stmt is LabelStatement label)
            {
                _labelMap[label.Name] = label.Name;
            }
        }

        // Generate header
        EmitComment("Generated by BASIC-IC10 Compiler for Stationeers");
        EmitComment("Professional Edition v1.0");
        Emit("");

        // Generate aliases and defines first
        foreach (var stmt in program.Statements)
        {
            if (stmt is AliasStatement alias)
            {
                GenerateAlias(alias);
            }
            else if (stmt is DefineStatement define)
            {
                GenerateDefine(define);
            }
        }

        if (_aliases.Count > 0 || _defines.Count > 0)
        {
            Emit("");
        }

        // Generate code for each statement
        for (int i = 0; i < program.Statements.Count; i++)
        {
            var stmt = program.Statements[i];

            // Emit label for BASIC line numbers
            if (stmt.BasicLineNumber.HasValue)
            {
                EmitLabel(_lineLabels[stmt.BasicLineNumber.Value]);
            }

            GenerateStatement(stmt);
        }

        return _output.ToString();
    }

    private void GenerateStatement(StatementNode stmt)
    {
        switch (stmt)
        {
            case LetStatement let:
                GenerateLet(let);
                break;
            case VarStatement varStmt:
                GenerateVar(varStmt);
                break;
            case ConstStatement constStmt:
                GenerateConst(constStmt);
                break;
            case PrintStatement print:
                GeneratePrint(print);
                break;
            case InputStatement input:
                GenerateInput(input);
                break;
            case IfStatement ifStmt:
                GenerateIf(ifStmt);
                break;
            case ForStatement forStmt:
                GenerateFor(forStmt);
                break;
            case WhileStatement whileStmt:
                GenerateWhile(whileStmt);
                break;
            case DoLoopStatement doLoop:
                GenerateDoLoop(doLoop);
                break;
            case GotoStatement gotoStmt:
                GenerateGoto(gotoStmt);
                break;
            case GosubStatement gosubStmt:
                GenerateGosub(gosubStmt);
                break;
            case LabelStatement labelStmt:
                EmitLabel(labelStmt.Name);
                break;
            case ReturnStatement ret:
                GenerateReturn(ret);
                break;
            case EndStatement:
                GenerateEnd();
                break;
            case BreakStatement:
                GenerateBreak();
                break;
            case ContinueStatement:
                GenerateContinue();
                break;
            case SleepStatement sleep:
                GenerateSleep(sleep);
                break;
            case YieldStatement:
                GenerateYield();
                break;
            case DeviceWriteStatement deviceWrite:
                GenerateDeviceWrite(deviceWrite);
                break;
            case DeviceSlotWriteStatement slotWrite:
                GenerateDeviceSlotWrite(slotWrite);
                break;
            case BatchWriteStatement batchWrite:
                GenerateBatchWrite(batchWrite);
                break;
            case AliasStatement:
            case DefineStatement:
                // Already handled in first pass
                break;
            case DimStatement dim:
                GenerateDim(dim);
                break;
            case SubDefinition sub:
                GenerateSubDefinition(sub);
                break;
            case FunctionDefinition func:
                GenerateFunctionDefinition(func);
                break;
            case CallStatement call:
                GenerateCall(call);
                break;
        }
    }

    private void GenerateLet(LetStatement let)
    {
        var valueReg = GenerateExpression(let.Value);
        var varReg = GetOrCreateVariable(let.VariableName);

        if (let.ArrayIndices != null && let.ArrayIndices.Count > 0)
        {
            var indexReg = GenerateExpression(let.ArrayIndices[0]);
            EmitComment($"Array store: {let.VariableName}[...]");
            Emit($"add r{TempRegister} {varReg} {indexReg}");
            Emit($"poke {valueReg} r{TempRegister}");
            FreeRegister(indexReg);
        }
        else
        {
            Emit($"move {varReg} {valueReg}");
        }

        FreeRegister(valueReg);
    }

    private void GenerateVar(VarStatement varStmt)
    {
        var varReg = GetOrCreateVariable(varStmt.VariableName);
        if (varStmt.InitialValue != null)
        {
            var valueReg = GenerateExpression(varStmt.InitialValue);
            Emit($"move {varReg} {valueReg}");
            FreeRegister(valueReg);
        }
        else
        {
            Emit($"move {varReg} 0");
        }
    }

    private void GenerateConst(ConstStatement constStmt)
    {
        if (constStmt.Value is NumberLiteral num)
        {
            _defines[constStmt.ConstantName] = num.Value;
            Emit($"define {constStmt.ConstantName} {FormatNumber(num.Value)}");
        }
    }

    private void GeneratePrint(PrintStatement print)
    {
        foreach (var expr in print.Expressions)
        {
            var reg = GenerateExpression(expr);
            EmitComment($"PRINT value in {reg}");
            // Write to db Setting for display
            Emit($"s db Setting {reg}");
            FreeRegister(reg);
        }
    }

    private void GenerateInput(InputStatement input)
    {
        var varReg = GetOrCreateVariable(input.VariableName);
        var device = input.DeviceName ?? "d0";
        var property = input.PropertyName ?? "Setting";
        EmitComment($"INPUT {input.VariableName}");
        Emit($"l {varReg} {device} {property}");
    }

    private void GenerateIf(IfStatement ifStmt)
    {
        var condReg = GenerateExpression(ifStmt.Condition);
        var elseLabel = NewLabel("else");
        var endLabel = NewLabel("endif");

        if (ifStmt.ElseBranch.Count > 0)
        {
            Emit($"beqz {condReg} {elseLabel}");
        }
        else
        {
            Emit($"beqz {condReg} {endLabel}");
        }
        FreeRegister(condReg);

        foreach (var stmt in ifStmt.ThenBranch)
        {
            GenerateStatement(stmt);
        }

        if (ifStmt.ElseBranch.Count > 0)
        {
            Emit($"j {endLabel}");
            EmitLabel(elseLabel);

            foreach (var stmt in ifStmt.ElseBranch)
            {
                GenerateStatement(stmt);
            }
        }

        EmitLabel(endLabel);
    }

    private void GenerateFor(ForStatement forStmt)
    {
        var loopVar = GetOrCreateVariable(forStmt.VariableName);
        var startReg = GenerateExpression(forStmt.StartValue);
        var endReg = AllocateRegister();
        var stepReg = AllocateRegister();

        var startLabel = NewLabel("for_start");
        var endLabel = NewLabel("for_end");
        var continueLabel = NewLabel("for_continue");

        _loopStartLabels.Push(continueLabel);
        _loopEndLabels.Push(endLabel);

        Emit($"move {loopVar} {startReg}");
        FreeRegister(startReg);

        var endValReg = GenerateExpression(forStmt.EndValue);
        Emit($"move {endReg} {endValReg}");
        FreeRegister(endValReg);

        if (forStmt.StepValue != null)
        {
            var stepValReg = GenerateExpression(forStmt.StepValue);
            Emit($"move {stepReg} {stepValReg}");
            FreeRegister(stepValReg);
        }
        else
        {
            Emit($"move {stepReg} 1");
        }

        EmitLabel(startLabel);

        // Use select for conditional comparison based on step sign
        Emit($"sgt r{TempRegister} {loopVar} {endReg}");
        Emit($"slt r{TempRegister2} {loopVar} {endReg}");
        Emit($"select r{TempRegister} {stepReg} r{TempRegister} r{TempRegister2}");
        Emit($"bgtz r{TempRegister} {endLabel}");

        foreach (var stmt in forStmt.Body)
        {
            GenerateStatement(stmt);
        }

        EmitLabel(continueLabel);
        Emit($"add {loopVar} {loopVar} {stepReg}");
        Emit($"j {startLabel}");

        EmitLabel(endLabel);

        _loopStartLabels.Pop();
        _loopEndLabels.Pop();
        FreeRegister(endReg);
        FreeRegister(stepReg);
    }

    private void GenerateWhile(WhileStatement whileStmt)
    {
        var startLabel = NewLabel("while_start");
        var endLabel = NewLabel("while_end");

        _loopStartLabels.Push(startLabel);
        _loopEndLabels.Push(endLabel);

        EmitLabel(startLabel);

        var condReg = GenerateExpression(whileStmt.Condition);
        Emit($"beqz {condReg} {endLabel}");
        FreeRegister(condReg);

        foreach (var stmt in whileStmt.Body)
        {
            GenerateStatement(stmt);
        }

        Emit($"j {startLabel}");
        EmitLabel(endLabel);

        _loopStartLabels.Pop();
        _loopEndLabels.Pop();
    }

    private void GenerateDoLoop(DoLoopStatement doLoop)
    {
        var startLabel = NewLabel("do_start");
        var endLabel = NewLabel("do_end");

        _loopStartLabels.Push(startLabel);
        _loopEndLabels.Push(endLabel);

        EmitLabel(startLabel);

        if (doLoop.ConditionAtStart)
        {
            if (doLoop.WhileCondition != null)
            {
                var condReg = GenerateExpression(doLoop.WhileCondition);
                Emit($"beqz {condReg} {endLabel}");
                FreeRegister(condReg);
            }
            else if (doLoop.UntilCondition != null)
            {
                var condReg = GenerateExpression(doLoop.UntilCondition);
                Emit($"bnez {condReg} {endLabel}");
                FreeRegister(condReg);
            }
        }

        foreach (var stmt in doLoop.Body)
        {
            GenerateStatement(stmt);
        }

        if (!doLoop.ConditionAtStart)
        {
            if (doLoop.WhileCondition != null)
            {
                var condReg = GenerateExpression(doLoop.WhileCondition);
                Emit($"bnez {condReg} {startLabel}");
                FreeRegister(condReg);
            }
            else if (doLoop.UntilCondition != null)
            {
                var condReg = GenerateExpression(doLoop.UntilCondition);
                Emit($"beqz {condReg} {startLabel}");
                FreeRegister(condReg);
            }
            else
            {
                Emit($"j {startLabel}");
            }
        }
        else
        {
            Emit($"j {startLabel}");
        }

        EmitLabel(endLabel);

        _loopStartLabels.Pop();
        _loopEndLabels.Pop();
    }

    private void GenerateGoto(GotoStatement gotoStmt)
    {
        if (gotoStmt.TargetLabel != null)
        {
            Emit($"j {gotoStmt.TargetLabel}");
        }
        else if (_lineLabels.TryGetValue(gotoStmt.TargetLine, out var label))
        {
            Emit($"j {label}");
        }
        else
        {
            EmitComment($"WARNING: Unknown line {gotoStmt.TargetLine}");
            Emit($"j line_{gotoStmt.TargetLine}");
        }
    }

    private void GenerateGosub(GosubStatement gosubStmt)
    {
        if (gosubStmt.TargetLabel != null)
        {
            Emit($"jal {gosubStmt.TargetLabel}");
        }
        else if (_lineLabels.TryGetValue(gosubStmt.TargetLine, out var label))
        {
            Emit($"jal {label}");
        }
        else
        {
            Emit($"jal line_{gosubStmt.TargetLine}");
        }
    }

    private void GenerateReturn(ReturnStatement ret)
    {
        if (ret.ReturnValue != null)
        {
            var valReg = GenerateExpression(ret.ReturnValue);
            Emit($"push {valReg}");
            FreeRegister(valReg);
        }
        Emit("j ra");
    }

    private void GenerateEnd()
    {
        EmitLabel("_end");
        Emit("hcf");
    }

    private void GenerateBreak()
    {
        if (_loopEndLabels.Count > 0)
        {
            Emit($"j {_loopEndLabels.Peek()}");
        }
    }

    private void GenerateContinue()
    {
        if (_loopStartLabels.Count > 0)
        {
            Emit($"j {_loopStartLabels.Peek()}");
        }
    }

    private void GenerateSleep(SleepStatement sleep)
    {
        var durationReg = GenerateExpression(sleep.Duration);
        Emit($"sleep {durationReg}");
        FreeRegister(durationReg);
    }

    private void GenerateYield()
    {
        Emit("yield");
    }

    private void GenerateAlias(AliasStatement alias)
    {
        _aliases[alias.AliasName] = alias.DeviceSpec;
        Emit($"alias {alias.AliasName} {alias.DeviceSpec}");
    }

    private void GenerateDefine(DefineStatement define)
    {
        if (define.Value is NumberLiteral num)
        {
            _defines[define.ConstantName] = num.Value;
            Emit($"define {define.ConstantName} {FormatNumber(num.Value)}");
        }
    }

    private void GenerateDim(DimStatement dim)
    {
        int size = 1;
        foreach (var d in dim.Dimensions)
        {
            if (d is NumberLiteral num)
            {
                size *= (int)(num.Value + 1);
            }
        }

        var baseReg = GetOrCreateVariable(dim.VariableName);
        Emit($"move {baseReg} {_stackPointer}");
        _stackPointer += size;

        EmitComment($"DIM {dim.VariableName} - allocated {size} slots");
    }

    private void GenerateDeviceWrite(DeviceWriteStatement write)
    {
        var valueReg = GenerateExpression(write.Value);
        var deviceSpec = _aliases.GetValueOrDefault(write.DeviceName, write.DeviceName);

        if (write.SlotIndex != null)
        {
            var slotReg = GenerateExpression(write.SlotIndex);
            Emit($"ss {deviceSpec} {slotReg} {write.PropertyName} {valueReg}");
            FreeRegister(slotReg);
        }
        else
        {
            Emit($"s {deviceSpec} {write.PropertyName} {valueReg}");
        }
        FreeRegister(valueReg);
    }

    private void GenerateDeviceSlotWrite(DeviceSlotWriteStatement write)
    {
        var valueReg = GenerateExpression(write.Value);
        var slotReg = GenerateExpression(write.SlotIndex);
        var deviceSpec = _aliases.GetValueOrDefault(write.DeviceName, write.DeviceName);
        Emit($"ss {deviceSpec} {slotReg} {write.PropertyName} {valueReg}");
        FreeRegister(slotReg);
        FreeRegister(valueReg);
    }

    private void GenerateBatchWrite(BatchWriteStatement write)
    {
        var hashReg = GenerateExpression(write.DeviceHash);
        var valueReg = GenerateExpression(write.Value);

        if (write.NameHash != null)
        {
            Emit($"sbn {hashReg} {write.NameHash} {write.PropertyName} {valueReg}");
        }
        else
        {
            Emit($"sb {hashReg} {write.PropertyName} {valueReg}");
        }

        FreeRegister(hashReg);
        FreeRegister(valueReg);
    }

    private void GenerateSubDefinition(SubDefinition sub)
    {
        EmitLabel(sub.Name);

        // Save parameters
        for (int i = 0; i < sub.Parameters.Count; i++)
        {
            var paramReg = GetOrCreateVariable(sub.Parameters[i]);
            Emit($"pop {paramReg}");
        }

        foreach (var stmt in sub.Body)
        {
            GenerateStatement(stmt);
        }

        Emit("j ra");
    }

    private void GenerateFunctionDefinition(FunctionDefinition func)
    {
        EmitLabel(func.Name);

        for (int i = 0; i < func.Parameters.Count; i++)
        {
            var paramReg = GetOrCreateVariable(func.Parameters[i]);
            Emit($"pop {paramReg}");
        }

        foreach (var stmt in func.Body)
        {
            GenerateStatement(stmt);
        }

        Emit("j ra");
    }

    private void GenerateCall(CallStatement call)
    {
        // Push arguments in reverse order
        for (int i = call.Arguments.Count - 1; i >= 0; i--)
        {
            var argReg = GenerateExpression(call.Arguments[i]);
            Emit($"push {argReg}");
            FreeRegister(argReg);
        }

        Emit($"jal {call.SubName}");
    }

    private string GenerateExpression(ExpressionNode expr)
    {
        switch (expr)
        {
            case NumberLiteral num:
                var numReg = AllocateRegister();
                Emit($"move {numReg} {FormatNumber(num.Value)}");
                return numReg;

            case BooleanLiteral boolean:
                var boolReg = AllocateRegister();
                Emit($"move {boolReg} {(boolean.Value ? 1 : 0)}");
                return boolReg;

            case StringLiteral str:
                var strReg = AllocateRegister();
                var hash = CalculateHash(str.Value);
                Emit($"move {strReg} {hash}");
                EmitComment($"String hash: \"{str.Value}\"");
                return strReg;

            case HashExpression hashExpr:
                var hashReg = AllocateRegister();
                var hashVal = CalculateHash(hashExpr.StringValue);
                Emit($"move {hashReg} {hashVal}");
                return hashReg;

            case VariableExpression varExpr:
                return GenerateVariableExpression(varExpr);

            case BinaryExpression bin:
                return GenerateBinaryExpression(bin);

            case UnaryExpression unary:
                return GenerateUnaryExpression(unary);

            case TernaryExpression ternary:
                return GenerateTernaryExpression(ternary);

            case FunctionCallExpression func:
                return GenerateFunctionCall(func);

            case DeviceReadExpression deviceRead:
                return GenerateDeviceRead(deviceRead);

            case DeviceSlotReadExpression slotRead:
                return GenerateDeviceSlotRead(slotRead);

            case BatchReadExpression batchRead:
                return GenerateBatchRead(batchRead);

            case ReagentReadExpression reagentRead:
                return GenerateReagentRead(reagentRead);

            default:
                var defaultReg = AllocateRegister();
                Emit($"move {defaultReg} 0");
                EmitComment("Unknown expression type");
                return defaultReg;
        }
    }

    private string GenerateVariableExpression(VariableExpression varExpr)
    {
        if (_defines.ContainsKey(varExpr.Name))
        {
            var constReg = AllocateRegister();
            Emit($"move {constReg} {varExpr.Name}");
            return constReg;
        }

        var varReg = GetOrCreateVariable(varExpr.Name);
        if (varExpr.ArrayIndices != null && varExpr.ArrayIndices.Count > 0)
        {
            var indexReg = GenerateExpression(varExpr.ArrayIndices[0]);
            var resultReg = AllocateRegister();
            Emit($"add r{TempRegister} {varReg} {indexReg}");
            Emit($"peek {resultReg} r{TempRegister}");
            FreeRegister(indexReg);
            return resultReg;
        }

        var copyReg = AllocateRegister();
        Emit($"move {copyReg} {varReg}");
        return copyReg;
    }

    private string GenerateBinaryExpression(BinaryExpression bin)
    {
        var leftReg = GenerateExpression(bin.Left);
        var rightReg = GenerateExpression(bin.Right);
        var resultReg = AllocateRegister();

        switch (bin.Operator)
        {
            case BinaryOperator.Add:
                Emit($"add {resultReg} {leftReg} {rightReg}");
                break;
            case BinaryOperator.Subtract:
                Emit($"sub {resultReg} {leftReg} {rightReg}");
                break;
            case BinaryOperator.Multiply:
                Emit($"mul {resultReg} {leftReg} {rightReg}");
                break;
            case BinaryOperator.Divide:
                Emit($"div {resultReg} {leftReg} {rightReg}");
                break;
            case BinaryOperator.Modulo:
                Emit($"mod {resultReg} {leftReg} {rightReg}");
                break;
            case BinaryOperator.Power:
                // a^b = exp(b * log(a))
                Emit($"log r{TempRegister} {leftReg}");
                Emit($"mul r{TempRegister} r{TempRegister} {rightReg}");
                Emit($"exp {resultReg} r{TempRegister}");
                break;
            case BinaryOperator.Equal:
                Emit($"seq {resultReg} {leftReg} {rightReg}");
                break;
            case BinaryOperator.NotEqual:
                Emit($"sne {resultReg} {leftReg} {rightReg}");
                break;
            case BinaryOperator.LessThan:
                Emit($"slt {resultReg} {leftReg} {rightReg}");
                break;
            case BinaryOperator.GreaterThan:
                Emit($"sgt {resultReg} {leftReg} {rightReg}");
                break;
            case BinaryOperator.LessEqual:
                Emit($"sle {resultReg} {leftReg} {rightReg}");
                break;
            case BinaryOperator.GreaterEqual:
                Emit($"sge {resultReg} {leftReg} {rightReg}");
                break;
            case BinaryOperator.ApproxEqual:
                // sap with default epsilon
                Emit($"sap {resultReg} {leftReg} {rightReg} 0.0001");
                break;
            case BinaryOperator.And:
                Emit($"and {resultReg} {leftReg} {rightReg}");
                break;
            case BinaryOperator.Or:
                Emit($"or {resultReg} {leftReg} {rightReg}");
                break;
            case BinaryOperator.BitAnd:
                Emit($"and {resultReg} {leftReg} {rightReg}");
                break;
            case BinaryOperator.BitOr:
                Emit($"or {resultReg} {leftReg} {rightReg}");
                break;
            case BinaryOperator.BitXor:
                Emit($"xor {resultReg} {leftReg} {rightReg}");
                break;
            case BinaryOperator.ShiftLeft:
                Emit($"sll {resultReg} {leftReg} {rightReg}");
                break;
            case BinaryOperator.ShiftRight:
                Emit($"srl {resultReg} {leftReg} {rightReg}");
                break;
            case BinaryOperator.ShiftRightArith:
                Emit($"sra {resultReg} {leftReg} {rightReg}");
                break;
        }

        FreeRegister(leftReg);
        FreeRegister(rightReg);
        return resultReg;
    }

    private string GenerateUnaryExpression(UnaryExpression unary)
    {
        var operandReg = GenerateExpression(unary.Operand);
        var resultReg = AllocateRegister();

        switch (unary.Operator)
        {
            case UnaryOperator.Negate:
                Emit($"sub {resultReg} 0 {operandReg}");
                break;
            case UnaryOperator.Not:
                Emit($"seqz {resultReg} {operandReg}");
                break;
            case UnaryOperator.BitNot:
                Emit($"nor {resultReg} {operandReg} {operandReg}");
                break;
        }

        FreeRegister(operandReg);
        return resultReg;
    }

    private string GenerateTernaryExpression(TernaryExpression ternary)
    {
        var condReg = GenerateExpression(ternary.Condition);
        var trueReg = GenerateExpression(ternary.TrueValue);
        var falseReg = GenerateExpression(ternary.FalseValue);
        var resultReg = AllocateRegister();

        // Use select instruction: select result condition trueVal falseVal
        Emit($"select {resultReg} {condReg} {trueReg} {falseReg}");

        FreeRegister(condReg);
        FreeRegister(trueReg);
        FreeRegister(falseReg);
        return resultReg;
    }

    private string GenerateDeviceRead(DeviceReadExpression read)
    {
        var resultReg = AllocateRegister();
        var deviceSpec = _aliases.GetValueOrDefault(read.DeviceName, read.DeviceName);

        if (read.SlotIndex != null)
        {
            var slotReg = GenerateExpression(read.SlotIndex);
            Emit($"ls {resultReg} {deviceSpec} {slotReg} {read.PropertyName}");
            FreeRegister(slotReg);
        }
        else
        {
            Emit($"l {resultReg} {deviceSpec} {read.PropertyName}");
        }
        return resultReg;
    }

    private string GenerateDeviceSlotRead(DeviceSlotReadExpression read)
    {
        var resultReg = AllocateRegister();
        var slotReg = GenerateExpression(read.SlotIndex);
        var deviceSpec = _aliases.GetValueOrDefault(read.DeviceName, read.DeviceName);
        Emit($"ls {resultReg} {deviceSpec} {slotReg} {read.PropertyName}");
        FreeRegister(slotReg);
        return resultReg;
    }

    private string GenerateBatchRead(BatchReadExpression read)
    {
        var resultReg = AllocateRegister();
        var hashReg = GenerateExpression(read.DeviceHash);

        var modeNum = read.Mode switch
        {
            BatchMode.Average => 0,
            BatchMode.Sum => 1,
            BatchMode.Minimum => 2,
            BatchMode.Maximum => 3,
            _ => 0
        };

        if (read.NameHash != null)
        {
            Emit($"lbn {resultReg} {hashReg} {read.NameHash} {read.PropertyName} {modeNum}");
        }
        else
        {
            Emit($"lb {resultReg} {hashReg} {read.PropertyName} {modeNum}");
        }

        FreeRegister(hashReg);
        return resultReg;
    }

    private string GenerateReagentRead(ReagentReadExpression read)
    {
        var resultReg = AllocateRegister();
        var modeReg = GenerateExpression(read.ReagentMode);
        var hashReg = GenerateExpression(read.ReagentHash);
        var deviceSpec = _aliases.GetValueOrDefault(read.DeviceName, read.DeviceName);

        Emit($"lr {resultReg} {deviceSpec} {modeReg} {hashReg}");

        FreeRegister(modeReg);
        FreeRegister(hashReg);
        return resultReg;
    }

    private string GenerateFunctionCall(FunctionCallExpression func)
    {
        var resultReg = AllocateRegister();
        var funcName = func.FunctionName.ToUpperInvariant();
        var argRegs = func.Arguments.Select(GenerateExpression).ToList();

        switch (funcName)
        {
            // Math functions
            case "ABS":
                Emit($"abs {resultReg} {argRegs[0]}");
                break;
            case "SIN":
                Emit($"sin {resultReg} {argRegs[0]}");
                break;
            case "COS":
                Emit($"cos {resultReg} {argRegs[0]}");
                break;
            case "TAN":
                Emit($"tan {resultReg} {argRegs[0]}");
                break;
            case "ASIN":
                Emit($"asin {resultReg} {argRegs[0]}");
                break;
            case "ACOS":
                Emit($"acos {resultReg} {argRegs[0]}");
                break;
            case "ATAN":
            case "ATN":
                Emit($"atan {resultReg} {argRegs[0]}");
                break;
            case "ATAN2":
                Emit($"atan2 {resultReg} {argRegs[0]} {argRegs[1]}");
                break;
            case "SQRT":
            case "SQR":
                Emit($"sqrt {resultReg} {argRegs[0]}");
                break;
            case "EXP":
                Emit($"exp {resultReg} {argRegs[0]}");
                break;
            case "LOG":
            case "LN":
                Emit($"log {resultReg} {argRegs[0]}");
                break;
            case "LOG10":
                Emit($"log {resultReg} {argRegs[0]}");
                Emit($"div {resultReg} {resultReg} 2.302585");
                break;
            case "CEIL":
                Emit($"ceil {resultReg} {argRegs[0]}");
                break;
            case "FLOOR":
                Emit($"floor {resultReg} {argRegs[0]}");
                break;
            case "ROUND":
                Emit($"round {resultReg} {argRegs[0]}");
                break;
            case "TRUNC":
            case "INT":
            case "FIX":
                Emit($"trunc {resultReg} {argRegs[0]}");
                break;
            case "MIN":
                Emit($"min {resultReg} {argRegs[0]} {argRegs[1]}");
                break;
            case "MAX":
                Emit($"max {resultReg} {argRegs[0]} {argRegs[1]}");
                break;
            case "RND":
            case "RAND":
                if (argRegs.Count > 0)
                {
                    Emit($"rand {resultReg}");
                    Emit($"mul {resultReg} {resultReg} {argRegs[0]}");
                }
                else
                {
                    Emit($"rand {resultReg}");
                }
                break;
            case "SGN":
                var sgnLabel = NewLabel("sgn");
                Emit($"sgtz {resultReg} {argRegs[0]}");
                Emit($"bgtz {resultReg} {sgnLabel}");
                Emit($"sltz {resultReg} {argRegs[0]}");
                Emit($"sub {resultReg} 0 {resultReg}");
                EmitLabel(sgnLabel);
                break;
            case "POW":
                Emit($"log r{TempRegister} {argRegs[0]}");
                Emit($"mul r{TempRegister} r{TempRegister} {argRegs[1]}");
                Emit($"exp {resultReg} r{TempRegister}");
                break;

            // Select/ternary function
            case "SELECT":
            case "IIF":
                Emit($"select {resultReg} {argRegs[0]} {argRegs[1]} {argRegs[2]}");
                break;

            // NaN handling functions
            case "ISNAN":
            case "SNAN":
                Emit($"snan {resultReg} {argRegs[0]}");
                break;
            case "ISNANORZERO":
            case "SNAZ":
                Emit($"snaz {resultReg} {argRegs[0]}");
                break;

            // Approximately equal
            case "APPROX":
            case "SAP":
                if (argRegs.Count >= 3)
                {
                    Emit($"sap {resultReg} {argRegs[0]} {argRegs[1]} {argRegs[2]}");
                }
                else
                {
                    Emit($"sap {resultReg} {argRegs[0]} {argRegs[1]} 0.0001");
                }
                break;
            case "SAPZ":
                if (argRegs.Count >= 2)
                {
                    Emit($"sapz {resultReg} {argRegs[0]} {argRegs[1]}");
                }
                else
                {
                    Emit($"sapz {resultReg} {argRegs[0]} 0.0001");
                }
                break;

            // Device existence checks
            case "SDSE":
                Emit($"sdse {resultReg} {argRegs[0]}");
                break;
            case "SDNS":
                Emit($"sdns {resultReg} {argRegs[0]}");
                break;

            // Bitwise functions
            case "BAND":
            case "BITAND":
                Emit($"and {resultReg} {argRegs[0]} {argRegs[1]}");
                break;
            case "BOR":
            case "BITOR":
                Emit($"or {resultReg} {argRegs[0]} {argRegs[1]}");
                break;
            case "BXOR":
            case "BITXOR":
                Emit($"xor {resultReg} {argRegs[0]} {argRegs[1]}");
                break;
            case "BNOT":
            case "BITNOT":
                Emit($"nor {resultReg} {argRegs[0]} {argRegs[0]}");
                break;
            case "BNOR":
            case "BITNOR":
                Emit($"nor {resultReg} {argRegs[0]} {argRegs[1]}");
                break;

            // Shift functions
            case "SHL":
            case "SHIFTL":
            case "LSHIFT":
                Emit($"sll {resultReg} {argRegs[0]} {argRegs[1]}");
                break;
            case "SHR":
            case "SHIFTR":
            case "RSHIFT":
                Emit($"srl {resultReg} {argRegs[0]} {argRegs[1]}");
                break;
            case "SHRA":
            case "SHIFTRA":
            case "RSHIFTA":
                Emit($"sra {resultReg} {argRegs[0]} {argRegs[1]}");
                break;

            // Comparison to zero functions
            case "SEQZ":
                Emit($"seqz {resultReg} {argRegs[0]}");
                break;
            case "SNEZ":
                Emit($"snez {resultReg} {argRegs[0]}");
                break;
            case "SGTZ":
                Emit($"sgtz {resultReg} {argRegs[0]}");
                break;
            case "SLTZ":
                Emit($"sltz {resultReg} {argRegs[0]}");
                break;
            case "SGEZ":
                Emit($"sgez {resultReg} {argRegs[0]}");
                break;
            case "SLEZ":
                Emit($"slez {resultReg} {argRegs[0]}");
                break;

            // Range check
            case "INRANGE":
                // Check if arg0 is between arg1 and arg2
                Emit($"sge r{TempRegister} {argRegs[0]} {argRegs[1]}");
                Emit($"sle r{TempRegister2} {argRegs[0]} {argRegs[2]}");
                Emit($"and {resultReg} r{TempRegister} r{TempRegister2}");
                break;

            // Interpolation
            case "LERP":
                // lerp(a, b, t) = a + t * (b - a)
                Emit($"sub r{TempRegister} {argRegs[1]} {argRegs[0]}");
                Emit($"mul r{TempRegister} r{TempRegister} {argRegs[2]}");
                Emit($"add {resultReg} {argRegs[0]} r{TempRegister}");
                break;

            // Clamp
            case "CLAMP":
                Emit($"max r{TempRegister} {argRegs[0]} {argRegs[1]}");
                Emit($"min {resultReg} r{TempRegister} {argRegs[2]}");
                break;

            // Hash function
            case "HASH":
                if (func.Arguments[0] is StringLiteral strArg)
                {
                    var hashVal = CalculateHash(strArg.Value);
                    Emit($"move {resultReg} {hashVal}");
                }
                else
                {
                    Emit($"move {resultReg} {argRegs[0]}");
                }
                break;

            default:
                // Check if it's a user-defined function
                Emit($"jal {funcName}");
                Emit($"pop {resultReg}");
                break;
        }

        foreach (var reg in argRegs)
        {
            FreeRegister(reg);
        }

        return resultReg;
    }

    // Stationeers uses CRC-32 for hash calculation
    private static readonly uint[] Crc32Table = GenerateCrc32Table();

    private static uint[] GenerateCrc32Table()
    {
        var table = new uint[256];
        const uint polynomial = 0xEDB88320; // Standard CRC-32 polynomial (reversed)

        for (uint i = 0; i < 256; i++)
        {
            uint crc = i;
            for (int j = 0; j < 8; j++)
            {
                if ((crc & 1) == 1)
                    crc = (crc >> 1) ^ polynomial;
                else
                    crc >>= 1;
            }
            table[i] = crc;
        }
        return table;
    }

    private static int CalculateHash(string str)
    {
        // Stationeers CRC-32 hash calculation
        uint crc = 0xFFFFFFFF;

        foreach (char c in str)
        {
            byte b = (byte)c;
            crc = (crc >> 8) ^ Crc32Table[(crc ^ b) & 0xFF];
        }

        // Return as signed int32 (Stationeers convention)
        return unchecked((int)(crc ^ 0xFFFFFFFF));
    }

    // Register allocation
    private readonly HashSet<int> _usedRegisters = new();

    private string AllocateRegister()
    {
        for (int i = 0; i < MaxRegisters; i++)
        {
            if (!_usedRegisters.Contains(i) && !_variables.ContainsValue(i))
            {
                _usedRegisters.Add(i);
                return $"r{i}";
            }
        }
        return $"r{TempRegister}";
    }

    private void FreeRegister(string reg)
    {
        if (reg.StartsWith("r") && int.TryParse(reg[1..], out var num))
        {
            if (!_variables.ContainsValue(num))
            {
                _usedRegisters.Remove(num);
            }
        }
    }

    private string GetOrCreateVariable(string name)
    {
        if (!_variables.TryGetValue(name, out var regNum))
        {
            for (int i = 0; i < MaxRegisters; i++)
            {
                if (!_variables.ContainsValue(i))
                {
                    regNum = i;
                    _variables[name] = i;
                    break;
                }
            }
        }
        return $"r{regNum}";
    }

    private string NewLabel(string prefix)
    {
        return $"{prefix}_{_nextLabel++}";
    }

    private static string FormatNumber(double value)
    {
        if (value == Math.Floor(value) && Math.Abs(value) < 1e10)
        {
            return ((long)value).ToString();
        }
        return value.ToString("G");
    }

    private void Emit(string line)
    {
        _output.AppendLine(line);
    }

    private void EmitLabel(string label)
    {
        _output.AppendLine($"{label}:");
    }

    private void EmitComment(string comment)
    {
        _output.AppendLine($"# {comment}");
    }
}
