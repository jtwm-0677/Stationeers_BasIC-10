using System.Text;
using BasicToMips.AST;

namespace BasicToMips.CodeGen;

public class MipsGenerator
{
    private readonly StringBuilder _output = new();
    private readonly Dictionary<string, int> _variables = new();
    private readonly Dictionary<string, int[]> _arrays = new();
    private readonly Dictionary<int, string> _lineLabels = new();
    private readonly Dictionary<string, string> _aliases = new();
    private readonly Dictionary<string, double> _defines = new();
    private readonly Stack<string> _loopEndLabels = new();
    private readonly Stack<string> _loopStartLabels = new();
    private readonly Stack<string> _gosubStack = new();

    private int _nextRegister = 0;
    private int _nextLabel = 0;
    private int _stackPointer = 0;
    private const int MaxRegisters = 16; // r0-r15 available for variables
    private const int StackRegister = 16; // sp for stack operations

    // Stationeers MIPS uses registers r0-r17 and special registers
    // We'll use r0-r15 for variables, r16 as stack pointer, r17 as temp

    public string Generate(ProgramNode program)
    {
        // First pass: collect all line labels
        foreach (var (lineNum, index) in program.LineNumberMap)
        {
            _lineLabels[lineNum] = $"line_{lineNum}";
        }

        // Generate header
        EmitComment("Generated by BASIC to Stationeers MIPS Compiler");
        EmitComment("https://github.com/your-repo/BasicToMips");
        Emit("");

        // Generate aliases and defines first
        foreach (var stmt in program.Statements)
        {
            if (stmt is AliasStatement alias)
            {
                GenerateAlias(alias);
            }
            else if (stmt is DefineStatement define)
            {
                GenerateDefine(define);
            }
        }

        if (_aliases.Count > 0 || _defines.Count > 0)
        {
            Emit("");
        }

        // Generate code for each statement
        for (int i = 0; i < program.Statements.Count; i++)
        {
            var stmt = program.Statements[i];

            // Emit label for BASIC line numbers
            if (stmt.BasicLineNumber.HasValue)
            {
                EmitLabel(_lineLabels[stmt.BasicLineNumber.Value]);
            }

            GenerateStatement(stmt);
        }

        return _output.ToString();
    }

    private void GenerateStatement(StatementNode stmt)
    {
        switch (stmt)
        {
            case LetStatement let:
                GenerateLet(let);
                break;
            case PrintStatement print:
                GeneratePrint(print);
                break;
            case InputStatement input:
                GenerateInput(input);
                break;
            case IfStatement ifStmt:
                GenerateIf(ifStmt);
                break;
            case ForStatement forStmt:
                GenerateFor(forStmt);
                break;
            case WhileStatement whileStmt:
                GenerateWhile(whileStmt);
                break;
            case DoLoopStatement doLoop:
                GenerateDoLoop(doLoop);
                break;
            case GotoStatement gotoStmt:
                GenerateGoto(gotoStmt);
                break;
            case GosubStatement gosubStmt:
                GenerateGosub(gosubStmt);
                break;
            case ReturnStatement:
                GenerateReturn();
                break;
            case EndStatement:
                GenerateEnd();
                break;
            case SleepStatement sleep:
                GenerateSleep(sleep);
                break;
            case YieldStatement:
                GenerateYield();
                break;
            case DeviceWriteStatement deviceWrite:
                GenerateDeviceWrite(deviceWrite);
                break;
            case AliasStatement:
            case DefineStatement:
                // Already handled in first pass
                break;
            case DimStatement dim:
                GenerateDim(dim);
                break;
            case SubDefinition:
                // Subroutines are handled separately
                break;
            case CallStatement call:
                GenerateCall(call);
                break;
        }
    }

    private void GenerateLet(LetStatement let)
    {
        var valueReg = GenerateExpression(let.Value);
        var varReg = GetOrCreateVariable(let.VariableName);

        if (let.ArrayIndices != null && let.ArrayIndices.Count > 0)
        {
            // Array assignment - use stack
            var indexReg = GenerateExpression(let.ArrayIndices[0]);
            // Store at stack position: base + index
            EmitComment($"Array store: {let.VariableName}[...]");
            Emit($"add r17 {varReg} {indexReg}");
            Emit($"poke {valueReg} r17");
            FreeRegister(indexReg);
        }
        else
        {
            Emit($"move {varReg} {valueReg}");
        }

        FreeRegister(valueReg);
    }

    private void GeneratePrint(PrintStatement print)
    {
        // Stationeers doesn't have direct print, but we can write to a display
        // For now, we'll emit comments showing what would be printed
        // In a real implementation, you'd write to db (display batch) device

        foreach (var expr in print.Expressions)
        {
            var reg = GenerateExpression(expr);
            EmitComment($"PRINT value in {reg}");
            // To actually display, you'd need: s db Setting {reg}
            // Or write to a memory cell for debugging
            FreeRegister(reg);
        }
    }

    private void GenerateInput(InputStatement input)
    {
        // Stationeers doesn't have keyboard input
        // We'll read from a device (like a dial or memory)
        var varReg = GetOrCreateVariable(input.VariableName);
        EmitComment($"INPUT {input.VariableName} - read from device");
        // Example: read from d0's Setting
        Emit($"l {varReg} d0 Setting");
    }

    private void GenerateIf(IfStatement ifStmt)
    {
        var condReg = GenerateExpression(ifStmt.Condition);
        var elseLabel = NewLabel("else");
        var endLabel = NewLabel("endif");

        // Branch to else if condition is false (zero)
        if (ifStmt.ElseBranch.Count > 0)
        {
            Emit($"beqz {condReg} {elseLabel}");
        }
        else
        {
            Emit($"beqz {condReg} {endLabel}");
        }
        FreeRegister(condReg);

        // Generate THEN branch
        foreach (var stmt in ifStmt.ThenBranch)
        {
            GenerateStatement(stmt);
        }

        if (ifStmt.ElseBranch.Count > 0)
        {
            Emit($"j {endLabel}");
            EmitLabel(elseLabel);

            // Generate ELSE branch
            foreach (var stmt in ifStmt.ElseBranch)
            {
                GenerateStatement(stmt);
            }
        }

        EmitLabel(endLabel);
    }

    private void GenerateFor(ForStatement forStmt)
    {
        var loopVar = GetOrCreateVariable(forStmt.VariableName);
        var startReg = GenerateExpression(forStmt.StartValue);
        var endReg = AllocateRegister();
        var stepReg = AllocateRegister();

        var startLabel = NewLabel("for_start");
        var endLabel = NewLabel("for_end");

        _loopStartLabels.Push(startLabel);
        _loopEndLabels.Push(endLabel);

        // Initialize loop variable
        Emit($"move {loopVar} {startReg}");
        FreeRegister(startReg);

        // Store end value
        var endValReg = GenerateExpression(forStmt.EndValue);
        Emit($"move {endReg} {endValReg}");
        FreeRegister(endValReg);

        // Store step value
        if (forStmt.StepValue != null)
        {
            var stepValReg = GenerateExpression(forStmt.StepValue);
            Emit($"move {stepReg} {stepValReg}");
            FreeRegister(stepValReg);
        }
        else
        {
            Emit($"move {stepReg} 1");
        }

        EmitLabel(startLabel);

        // Check loop condition
        // If step is positive: loopVar > endValue means exit
        // If step is negative: loopVar < endValue means exit
        Emit($"sgt r17 {loopVar} {endReg}");
        Emit($"bgtz {stepReg} 3"); // If step > 0, check if var > end
        Emit($"slt r17 {loopVar} {endReg}"); // Else check if var < end
        Emit($"bnez r17 {endLabel}");

        // Generate loop body
        foreach (var stmt in forStmt.Body)
        {
            GenerateStatement(stmt);
        }

        // Increment loop variable
        Emit($"add {loopVar} {loopVar} {stepReg}");
        Emit($"j {startLabel}");

        EmitLabel(endLabel);

        _loopStartLabels.Pop();
        _loopEndLabels.Pop();
        FreeRegister(endReg);
        FreeRegister(stepReg);
    }

    private void GenerateWhile(WhileStatement whileStmt)
    {
        var startLabel = NewLabel("while_start");
        var endLabel = NewLabel("while_end");

        _loopStartLabels.Push(startLabel);
        _loopEndLabels.Push(endLabel);

        EmitLabel(startLabel);

        var condReg = GenerateExpression(whileStmt.Condition);
        Emit($"beqz {condReg} {endLabel}");
        FreeRegister(condReg);

        foreach (var stmt in whileStmt.Body)
        {
            GenerateStatement(stmt);
        }

        Emit($"j {startLabel}");
        EmitLabel(endLabel);

        _loopStartLabels.Pop();
        _loopEndLabels.Pop();
    }

    private void GenerateDoLoop(DoLoopStatement doLoop)
    {
        var startLabel = NewLabel("do_start");
        var endLabel = NewLabel("do_end");

        _loopStartLabels.Push(startLabel);
        _loopEndLabels.Push(endLabel);

        EmitLabel(startLabel);

        // Condition at start
        if (doLoop.ConditionAtStart)
        {
            if (doLoop.WhileCondition != null)
            {
                var condReg = GenerateExpression(doLoop.WhileCondition);
                Emit($"beqz {condReg} {endLabel}");
                FreeRegister(condReg);
            }
            else if (doLoop.UntilCondition != null)
            {
                var condReg = GenerateExpression(doLoop.UntilCondition);
                Emit($"bnez {condReg} {endLabel}");
                FreeRegister(condReg);
            }
        }

        foreach (var stmt in doLoop.Body)
        {
            GenerateStatement(stmt);
        }

        // Condition at end
        if (!doLoop.ConditionAtStart)
        {
            if (doLoop.WhileCondition != null)
            {
                var condReg = GenerateExpression(doLoop.WhileCondition);
                Emit($"bnez {condReg} {startLabel}");
                FreeRegister(condReg);
            }
            else if (doLoop.UntilCondition != null)
            {
                var condReg = GenerateExpression(doLoop.UntilCondition);
                Emit($"beqz {condReg} {startLabel}");
                FreeRegister(condReg);
            }
            else
            {
                Emit($"j {startLabel}");
            }
        }
        else
        {
            Emit($"j {startLabel}");
        }

        EmitLabel(endLabel);

        _loopStartLabels.Pop();
        _loopEndLabels.Pop();
    }

    private void GenerateGoto(GotoStatement gotoStmt)
    {
        if (_lineLabels.TryGetValue(gotoStmt.TargetLine, out var label))
        {
            Emit($"j {label}");
        }
        else
        {
            EmitComment($"ERROR: Unknown line {gotoStmt.TargetLine}");
            Emit($"j line_{gotoStmt.TargetLine}");
        }
    }

    private void GenerateGosub(GosubStatement gosubStmt)
    {
        var returnLabel = NewLabel("return");
        _gosubStack.Push(returnLabel);

        // Push return address (we'll use line number as pseudo-address)
        Emit($"push {_output.ToString().Split('\n').Length}");

        if (_lineLabels.TryGetValue(gosubStmt.TargetLine, out var label))
        {
            Emit($"j {label}");
        }
        else
        {
            Emit($"j line_{gosubStmt.TargetLine}");
        }

        EmitLabel(returnLabel);
    }

    private void GenerateReturn()
    {
        // Pop return address and jump
        Emit("pop r17");
        Emit("jr r17");
    }

    private void GenerateEnd()
    {
        // Halt the program - in Stationeers, we jump to end or use hcf
        Emit("j _end");
        EmitLabel("_end");
        // Could use: hcf (halt and catch fire) for hard stop
    }

    private void GenerateSleep(SleepStatement sleep)
    {
        var durationReg = GenerateExpression(sleep.Duration);
        Emit($"sleep {durationReg}");
        FreeRegister(durationReg);
    }

    private void GenerateYield()
    {
        Emit("yield");
    }

    private void GenerateAlias(AliasStatement alias)
    {
        _aliases[alias.AliasName] = alias.DeviceSpec;
        Emit($"alias {alias.AliasName} {alias.DeviceSpec}");
    }

    private void GenerateDefine(DefineStatement define)
    {
        _defines[define.ConstantName] = define.Value;
        Emit($"define {define.ConstantName} {define.Value}");
    }

    private void GenerateDim(DimStatement dim)
    {
        // Allocate space in our simulated stack
        int size = 1;
        foreach (var d in dim.Dimensions)
        {
            size *= (d + 1); // BASIC arrays are 0-based to N inclusive
        }
        _arrays[dim.VariableName] = dim.Dimensions.ToArray();

        var baseReg = GetOrCreateVariable(dim.VariableName);
        Emit($"move {baseReg} {_stackPointer}");
        _stackPointer += size;

        EmitComment($"DIM {dim.VariableName} - allocated {size} slots at stack position");
    }

    private void GenerateDeviceWrite(DeviceWriteStatement write)
    {
        var valueReg = GenerateExpression(write.Value);
        var deviceSpec = _aliases.GetValueOrDefault(write.DeviceName, write.DeviceName);
        Emit($"s {deviceSpec} {write.PropertyName} {valueReg}");
        FreeRegister(valueReg);
    }

    private void GenerateCall(CallStatement call)
    {
        // For subroutines, we'd need to set up parameters
        EmitComment($"CALL {call.SubName}");
        Emit($"jal {call.SubName}");
    }

    private string GenerateExpression(ExpressionNode expr)
    {
        switch (expr)
        {
            case NumberLiteral num:
                var numReg = AllocateRegister();
                Emit($"move {numReg} {FormatNumber(num.Value)}");
                return numReg;

            case StringLiteral str:
                // Strings are tricky in MIPS - we'll hash them to a number
                var strReg = AllocateRegister();
                Emit($"move {strReg} {str.Value.GetHashCode()}");
                EmitComment($"String: \"{str.Value}\"");
                return strReg;

            case VariableExpression varExpr:
                if (_defines.TryGetValue(varExpr.Name, out var constVal))
                {
                    var constReg = AllocateRegister();
                    Emit($"move {constReg} {varExpr.Name}");
                    return constReg;
                }

                var varReg = GetOrCreateVariable(varExpr.Name);
                if (varExpr.ArrayIndices != null && varExpr.ArrayIndices.Count > 0)
                {
                    var indexReg = GenerateExpression(varExpr.ArrayIndices[0]);
                    var resultReg = AllocateRegister();
                    Emit($"add r17 {varReg} {indexReg}");
                    Emit($"peek {resultReg} r17");
                    FreeRegister(indexReg);
                    return resultReg;
                }
                // Return a copy to avoid issues
                var copyReg = AllocateRegister();
                Emit($"move {copyReg} {varReg}");
                return copyReg;

            case BinaryExpression bin:
                return GenerateBinaryExpression(bin);

            case UnaryExpression unary:
                return GenerateUnaryExpression(unary);

            case FunctionCallExpression func:
                return GenerateFunctionCall(func);

            case DeviceReadExpression deviceRead:
                var readReg = AllocateRegister();
                var deviceSpec = _aliases.GetValueOrDefault(deviceRead.DeviceName, deviceRead.DeviceName);
                Emit($"l {readReg} {deviceSpec} {deviceRead.PropertyName}");
                return readReg;

            default:
                var defaultReg = AllocateRegister();
                Emit($"move {defaultReg} 0");
                EmitComment("Unknown expression type");
                return defaultReg;
        }
    }

    private string GenerateBinaryExpression(BinaryExpression bin)
    {
        var leftReg = GenerateExpression(bin.Left);
        var rightReg = GenerateExpression(bin.Right);
        var resultReg = AllocateRegister();

        var instruction = bin.Operator switch
        {
            BinaryOperator.Add => "add",
            BinaryOperator.Subtract => "sub",
            BinaryOperator.Multiply => "mul",
            BinaryOperator.Divide => "div",
            BinaryOperator.Modulo => "mod",
            BinaryOperator.Power => "exp", // Note: Stationeers uses different approach
            BinaryOperator.Equal => "seq",
            BinaryOperator.NotEqual => "sne",
            BinaryOperator.LessThan => "slt",
            BinaryOperator.GreaterThan => "sgt",
            BinaryOperator.LessEqual => "sle",
            BinaryOperator.GreaterEqual => "sge",
            BinaryOperator.And => "and",
            BinaryOperator.Or => "or",
            _ => "move"
        };

        if (bin.Operator == BinaryOperator.Power)
        {
            // Power needs special handling - use log and exp
            // a^b = exp(b * log(a))
            Emit($"log r17 {leftReg}");
            Emit($"mul r17 r17 {rightReg}");
            Emit($"exp {resultReg} r17");
        }
        else
        {
            Emit($"{instruction} {resultReg} {leftReg} {rightReg}");
        }

        FreeRegister(leftReg);
        FreeRegister(rightReg);
        return resultReg;
    }

    private string GenerateUnaryExpression(UnaryExpression unary)
    {
        var operandReg = GenerateExpression(unary.Operand);
        var resultReg = AllocateRegister();

        switch (unary.Operator)
        {
            case UnaryOperator.Negate:
                Emit($"sub {resultReg} 0 {operandReg}");
                break;
            case UnaryOperator.Not:
                Emit($"seqz {resultReg} {operandReg}");
                break;
        }

        FreeRegister(operandReg);
        return resultReg;
    }

    private string GenerateFunctionCall(FunctionCallExpression func)
    {
        var resultReg = AllocateRegister();
        var funcName = func.FunctionName.ToUpperInvariant();

        // Generate argument registers
        var argRegs = func.Arguments.Select(GenerateExpression).ToList();

        switch (funcName)
        {
            case "ABS":
                Emit($"abs {resultReg} {argRegs[0]}");
                break;
            case "SIN":
                Emit($"sin {resultReg} {argRegs[0]}");
                break;
            case "COS":
                Emit($"cos {resultReg} {argRegs[0]}");
                break;
            case "TAN":
                Emit($"tan {resultReg} {argRegs[0]}");
                break;
            case "ASIN":
                Emit($"asin {resultReg} {argRegs[0]}");
                break;
            case "ACOS":
                Emit($"acos {resultReg} {argRegs[0]}");
                break;
            case "ATAN":
            case "ATN":
                Emit($"atan {resultReg} {argRegs[0]}");
                break;
            case "ATAN2":
                Emit($"atan2 {resultReg} {argRegs[0]} {argRegs[1]}");
                break;
            case "SQRT":
            case "SQR":
                Emit($"sqrt {resultReg} {argRegs[0]}");
                break;
            case "EXP":
                Emit($"exp {resultReg} {argRegs[0]}");
                break;
            case "LOG":
                Emit($"log {resultReg} {argRegs[0]}");
                break;
            case "LOG10":
                // log10(x) = log(x) / log(10)
                Emit($"log {resultReg} {argRegs[0]}");
                Emit($"div {resultReg} {resultReg} 2.302585");
                break;
            case "CEIL":
                Emit($"ceil {resultReg} {argRegs[0]}");
                break;
            case "FLOOR":
                Emit($"floor {resultReg} {argRegs[0]}");
                break;
            case "ROUND":
                Emit($"round {resultReg} {argRegs[0]}");
                break;
            case "TRUNC":
            case "INT":
            case "FIX":
                Emit($"trunc {resultReg} {argRegs[0]}");
                break;
            case "MIN":
                Emit($"min {resultReg} {argRegs[0]} {argRegs[1]}");
                break;
            case "MAX":
                Emit($"max {resultReg} {argRegs[0]} {argRegs[1]}");
                break;
            case "RND":
            case "RAND":
                if (argRegs.Count > 0)
                {
                    Emit($"rand {resultReg}");
                    Emit($"mul {resultReg} {resultReg} {argRegs[0]}");
                }
                else
                {
                    Emit($"rand {resultReg}");
                }
                break;
            case "SGN":
                // Sign function: -1, 0, or 1
                var tempLabel1 = NewLabel("sgn");
                var tempLabel2 = NewLabel("sgn");
                Emit($"sgtz {resultReg} {argRegs[0]}");
                Emit($"bgtz {resultReg} {tempLabel1}");
                Emit($"sltz {resultReg} {argRegs[0]}");
                Emit($"sub {resultReg} 0 {resultReg}");
                EmitLabel(tempLabel1);
                break;
            case "POW":
                // a^b = exp(b * log(a))
                Emit($"log r17 {argRegs[0]}");
                Emit($"mul r17 r17 {argRegs[1]}");
                Emit($"exp {resultReg} r17");
                break;
            default:
                EmitComment($"Unknown function: {funcName}");
                Emit($"move {resultReg} 0");
                break;
        }

        // Free argument registers
        foreach (var reg in argRegs)
        {
            FreeRegister(reg);
        }

        return resultReg;
    }

    // Register allocation (simple linear allocation)
    private readonly HashSet<int> _usedRegisters = new();

    private string AllocateRegister()
    {
        for (int i = 0; i < MaxRegisters; i++)
        {
            if (!_usedRegisters.Contains(i) && !_variables.ContainsValue(i))
            {
                _usedRegisters.Add(i);
                return $"r{i}";
            }
        }
        // Fallback to r17 (temp register)
        return "r17";
    }

    private void FreeRegister(string reg)
    {
        if (reg.StartsWith("r") && int.TryParse(reg[1..], out var num))
        {
            // Only free if not a variable register
            if (!_variables.ContainsValue(num))
            {
                _usedRegisters.Remove(num);
            }
        }
    }

    private string GetOrCreateVariable(string name)
    {
        if (!_variables.TryGetValue(name, out var regNum))
        {
            // Find first available register
            for (int i = 0; i < MaxRegisters; i++)
            {
                if (!_variables.ContainsValue(i))
                {
                    regNum = i;
                    _variables[name] = i;
                    break;
                }
            }
        }
        return $"r{regNum}";
    }

    private string NewLabel(string prefix)
    {
        return $"{prefix}_{_nextLabel++}";
    }

    private static string FormatNumber(double value)
    {
        if (value == Math.Floor(value) && Math.Abs(value) < 1e10)
        {
            return ((long)value).ToString();
        }
        return value.ToString("G");
    }

    private void Emit(string line)
    {
        _output.AppendLine(line);
    }

    private void EmitLabel(string label)
    {
        _output.AppendLine($"{label}:");
    }

    private void EmitComment(string comment)
    {
        _output.AppendLine($"# {comment}");
    }
}
