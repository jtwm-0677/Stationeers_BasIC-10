# v1.9.0 Documentation Update

**Document:** In-App Documentation Updates for Basic-10 v1.9.0/v1.9.1
**Location:** `docs/plans/v1.9.0_documentation_update.md`
**Date:** 2025-12-02
**Author:** Claude Code (QA Instance)

---

## Purpose

This document contains comprehensive documentation content to be added to `UI/Services/DocumentationService.cs` for the v1.9.0/v1.9.1 release features.

---

## Section 1: Syntax Tab Updates

### Add to Operators Section: Compound Assignment Operators (NEW in v1.9.0)

```csharp
AddSubHeader(panel, "Compound Assignment Operators");
AddCompactList(panel, new[]
{
    ("x += n", "Add n to x (x = x + n)"),
    ("x -= n", "Subtract n from x (x = x - n)"),
    ("x *= n", "Multiply x by n (x = x * n)"),
    ("x /= n", "Divide x by n (x = x / n)")
});
AddCodeBlock(panel, @"VAR x = 10
x += 5    # x is now 15
x -= 3    # x is now 12
x *= 2    # x is now 24
x /= 4    # x is now 6");
```

### Add to Operators Section: Increment/Decrement Operators (NEW in v1.9.0)

```csharp
AddSubHeader(panel, "Increment/Decrement Operators");
AddCompactList(panel, new[]
{
    ("++x", "Prefix increment (increment first, return new value)"),
    ("x++", "Postfix increment (return old value, then increment)"),
    ("--x", "Prefix decrement (decrement first, return new value)"),
    ("x--", "Postfix decrement (return old value, then decrement)")
});
AddCodeBlock(panel, @"VAR x = 10
VAR y = ++x    # x=11, y=11 (prefix: increment first)
VAR z = x++    # x=12, z=11 (postfix: return old value)

# Standalone usage in loops
VAR i = 0
WHILE i < 5
    ++i    # Works as statement
WEND");
```

### Update Bitwise Operators Section

Replace existing bitwise operators list with:

```csharp
AddSubHeader(panel, "Bitwise Operators");
AddCompactList(panel, new[]
{
    ("a & b or BAND(a,b)", "Bitwise AND"),
    ("a | b or BOR(a,b)", "Bitwise OR"),
    ("a ^ b or BXOR(a,b)", "Bitwise XOR"),
    ("~a or BNOT(a)", "Bitwise NOT"),
    ("a << n or SHL(a,n)", "Shift left n bits"),
    ("a >> n or SHR(a,n)", "Shift right n bits")
});
AddCodeBlock(panel, @"VAR a = 1
VAR b = a << 4    # b = 16 (shift left 4 bits)
VAR c = 16 >> 2   # c = 4 (shift right 2 bits)
VAR d = 5 ^ 3     # d = 6 (XOR: 101 ^ 011 = 110)");
```

### Add Loop Control Section

```csharp
AddHeader(panel, "Loop Control");
AddSyntaxEntry(panel, "BREAK", "Exit loop immediately", "WHILE 1\n    IF done THEN BREAK\n    YIELD\nWEND");
AddSyntaxEntry(panel, "CONTINUE", "Skip to next iteration", "FOR i = 1 TO 10\n    IF skip THEN CONTINUE\n    # Process non-skipped\nNEXT i");
```

---

## Section 2: IC10 Reference Tab Updates

### Add to Logic & Comparison Section: Shift Instructions

```csharp
AddIC10Entry(panel, "sll r0 r1 r2", "r0 = r1 << r2", "Shift left logical");
AddIC10Entry(panel, "srl r0 r1 r2", "r0 = r1 >> r2", "Shift right logical");
AddIC10Entry(panel, "sra r0 r1 r2", "r0 = r1 >>> r2", "Shift right arithmetic");
```

---

## Section 3: Complete IC10 Reference

### Registers
| Register | Description |
|----------|-------------|
| `r0` - `r15` | General purpose registers (16 total) |
| `sp` | Stack pointer |
| `ra` | Return address (for subroutines) |
| `d0` - `d5` | Device references |
| `db` | IC housing device (self-reference) |

### Math Operations
| Instruction | Meaning | Description |
|-------------|---------|-------------|
| `add r0 r1 r2` | r0 = r1 + r2 | Addition |
| `sub r0 r1 r2` | r0 = r1 - r2 | Subtraction |
| `mul r0 r1 r2` | r0 = r1 * r2 | Multiplication |
| `div r0 r1 r2` | r0 = r1 / r2 | Division |
| `mod r0 r1 r2` | r0 = r1 % r2 | Modulo |
| `exp r0 r1` | r0 = e^r1 | Exponential |
| `log r0 r1` | r0 = ln(r1) | Natural log |
| `sqrt r0 r1` | r0 = âˆšr1 | Square root |
| `abs r0 r1` | r0 = \|r1\| | Absolute value |
| `round r0 r1` | r0 = round(r1) | Round to integer |
| `trunc r0 r1` | r0 = trunc(r1) | Truncate |
| `ceil r0 r1` | r0 = ceil(r1) | Round up |
| `floor r0 r1` | r0 = floor(r1) | Round down |
| `min r0 r1 r2` | r0 = min(r1,r2) | Minimum |
| `max r0 r1 r2` | r0 = max(r1,r2) | Maximum |
| `rand r0` | r0 = random(0-1) | Random number |

### Trigonometry
| Instruction | Meaning | Description |
|-------------|---------|-------------|
| `sin r0 r1` | r0 = sin(r1) | Sine (radians) |
| `cos r0 r1` | r0 = cos(r1) | Cosine |
| `tan r0 r1` | r0 = tan(r1) | Tangent |
| `asin r0 r1` | r0 = asin(r1) | Arc sine |
| `acos r0 r1` | r0 = acos(r1) | Arc cosine |
| `atan r0 r1` | r0 = atan(r1) | Arc tangent |
| `atan2 r0 r1 r2` | r0 = atan2(r1,r2) | Two-argument atan |

### Logic & Bitwise Operations
| Instruction | Meaning | Description |
|-------------|---------|-------------|
| `and r0 r1 r2` | r0 = r1 & r2 | Bitwise AND |
| `or r0 r1 r2` | r0 = r1 \| r2 | Bitwise OR |
| `xor r0 r1 r2` | r0 = r1 ^ r2 | Bitwise XOR |
| `nor r0 r1 r2` | r0 = ~(r1 \| r2) | NOR |
| `not r0 r1` | r0 = ~r1 | Bitwise NOT |
| `sll r0 r1 r2` | r0 = r1 << r2 | Shift left logical |
| `srl r0 r1 r2` | r0 = r1 >> r2 | Shift right logical |
| `sra r0 r1 r2` | r0 = r1 >>> r2 | Shift right arithmetic |

### Comparison (Set Instructions)
| Instruction | Meaning | Description |
|-------------|---------|-------------|
| `slt r0 r1 r2` | r0 = (r1 < r2) | Set if less than |
| `sgt r0 r1 r2` | r0 = (r1 > r2) | Set if greater |
| `sle r0 r1 r2` | r0 = (r1 <= r2) | Set if less/equal |
| `sge r0 r1 r2` | r0 = (r1 >= r2) | Set if greater/equal |
| `seq r0 r1 r2` | r0 = (r1 == r2) | Set if equal |
| `sne r0 r1 r2` | r0 = (r1 != r2) | Set if not equal |
| `seqz r0 r1` | r0 = (r1 == 0) | Set if zero |
| `snez r0 r1` | r0 = (r1 != 0) | Set if not zero |
| `snan r0 r1` | r0 = isNaN(r1) | Set if NaN |

### Branching & Jumps
| Instruction | Meaning | Description |
|-------------|---------|-------------|
| `j label` | goto label | Unconditional jump |
| `jr r0` | goto r0 | Jump to register |
| `jal label` | call label | Jump and link (saves ra) |
| `beq r0 r1 label` | if r0==r1 goto | Branch if equal |
| `bne r0 r1 label` | if r0!=r1 goto | Branch if not equal |
| `blt r0 r1 label` | if r0<r1 goto | Branch if less than |
| `bgt r0 r1 label` | if r0>r1 goto | Branch if greater |
| `ble r0 r1 label` | if r0<=r1 goto | Branch if less/equal |
| `bge r0 r1 label` | if r0>=r1 goto | Branch if greater/equal |
| `beqz r0 label` | if r0==0 goto | Branch if zero |
| `bnez r0 label` | if r0!=0 goto | Branch if not zero |
| `bnan r0 label` | if isNaN(r0) goto | Branch if NaN |

### Device Operations
| Instruction | Meaning | Description |
|-------------|---------|-------------|
| `l r0 d0 Prop` | r0 = d0.Prop | Load from device |
| `s d0 Prop r0` | d0.Prop = r0 | Store to device |
| `ls r0 d0 slot Prop` | r0 = d0.Slot(n).Prop | Load slot property |
| `ss d0 slot Prop r0` | d0.Slot(n).Prop = r0 | Store slot property |
| `lb r0 hash Prop mode` | batch read | Load batch |
| `sb hash Prop r0` | batch write | Store batch |
| `lbn r0 hash name Prop mode` | named batch read | Load batch by name |
| `sbn hash name Prop r0` | named batch write | Store batch by name |

### Stack Operations
| Instruction | Meaning | Description |
|-------------|---------|-------------|
| `push r0` | stack.push(r0) | Push to stack |
| `pop r0` | r0 = stack.pop() | Pop from stack |
| `peek r0` | r0 = stack.peek() | Peek stack top |

### Special Instructions
| Instruction | Meaning | Description |
|-------------|---------|-------------|
| `move r0 r1` | r0 = r1 | Copy value |
| `yield` | pause 1 tick | Yield execution |
| `sleep r0` | pause r0 seconds | Sleep for time |
| `alias name d0` | name = d0 | Create alias |
| `define name value` | const = value | Define constant |
| `hcf` | halt | Halt and catch fire |
| `select r0 r1 r2 r3` | r0 = r1?r2:r3 | Conditional select |

---

## Section 4: New Example Programs

### Example 16: Counter with Increment/Decrement

```csharp
new()
{
    Name = "16: Counter with Increment/Decrement",
    Description = "Demonstrates ++/-- operators for counting.\nDevices: d0 = LED Display, d1 = Up Button, d2 = Down Button",
    Code = @"# Counter Demo - Increment/Decrement Operators
ALIAS display d0
ALIAS upBtn d1
ALIAS downBtn d2

VAR count = 0
VAR lastUp = 0
VAR lastDown = 0

main:
    VAR currentUp = upBtn.Setting
    VAR currentDown = downBtn.Setting

    # Edge detection with increment
    IF currentUp = 1 AND lastUp = 0 THEN
        ++count
    ENDIF

    IF currentDown = 1 AND lastDown = 0 THEN
        --count
    ENDIF

    lastUp = currentUp
    lastDown = currentDown
    display.Setting = count

    YIELD
    GOTO main
END
"
}
```

### Example 17: Smooth Value Adjustment

```csharp
new()
{
    Name = "17: Smooth Value Adjustment",
    Description = "Uses compound assignment for gradual changes.\nDevices: d0 = Dial, d1 = Pump, d2 = LED Display",
    Code = @"# Smooth Adjustment with Compound Assignment
ALIAS dial d0
ALIAS pump d1
ALIAS display d2

VAR targetPressure = 50
VAR currentSetting = 0
CONST STEP = 2

main:
    targetPressure = dial.Setting

    # Gradually adjust toward target
    IF currentSetting < targetPressure THEN
        currentSetting += STEP
    ELSEIF currentSetting > targetPressure THEN
        currentSetting -= STEP
    ENDIF

    pump.Setting = currentSetting
    display.Setting = currentSetting

    YIELD
    GOTO main
END
"
}
```

### Example 18: Bit Flag Status System

```csharp
new()
{
    Name = "18: Bit Flag Status System",
    Description = "Uses bit shifts for compact status tracking.\nDevices: d0 = Gas Sensor, d1 = LED Display",
    Code = @"# Status Flag System using Bit Shifts
ALIAS sensor d0
ALIAS display d1

# Status bits: bit0=power, bit1=temp, bit2=pressure, bit3=oxygen
VAR status = 0
CONST POWER_BIT = 0
CONST TEMP_BIT = 1
CONST PRESSURE_BIT = 2
CONST OXYGEN_BIT = 3

main:
    status = 0

    IF sensor.Power > 0 THEN
        status = status | (1 << POWER_BIT)
    ENDIF

    IF sensor.Temperature > 250 AND sensor.Temperature < 320 THEN
        status = status | (1 << TEMP_BIT)
    ENDIF

    IF sensor.Pressure > 80 AND sensor.Pressure < 120 THEN
        status = status | (1 << PRESSURE_BIT)
    ENDIF

    IF sensor.RatioOxygen > 0.18 AND sensor.RatioOxygen < 0.25 THEN
        status = status | (1 << OXYGEN_BIT)
    ENDIF

    # Display status (15 = all OK)
    display.Setting = status

    YIELD
    GOTO main
END
"
}
```

### Example 19: Loop with BREAK/CONTINUE

```csharp
new()
{
    Name = "19: Loop with BREAK/CONTINUE",
    Description = "Demonstrates loop control statements.\nDevices: d0 = Sorter, d1 = LED Display",
    Code = @"# Search with Loop Control
ALIAS sorter d0
ALIAS display d1

DEFINE TARGET_HASH -707307845

VAR found = 0

main:
    found = 0

    FOR slot = 0 TO 5
        VAR hash = sorter.Slot(slot).OccupantHash

        # Skip empty slots
        IF hash = 0 THEN CONTINUE

        # Found target - exit early
        IF hash = TARGET_HASH THEN
            found = 1
            BREAK
        ENDIF
    NEXT slot

    display.Setting = found

    YIELD
    GOTO main
END
"
}
```

---

## Section 5: Tips & Patterns Updates

### Add to Patterns Tab: Compound Assignment Tips

```csharp
AddSubHeader(panel, "Using Compound Assignment");
AddParagraph(panel, "Use += and -= for accumulators and counters:");
AddCodeBlock(panel, @"VAR total = 0
VAR count = 0

main:
    total += sensor.Reading    # Accumulate readings
    count += 1                 # Count iterations

    VAR average = total / count
    YIELD
    GOTO main");
```

### Add to Patterns Tab: Increment/Decrement Tips

```csharp
AddSubHeader(panel, "Prefix vs Postfix Increment");
AddParagraph(panel, "Use prefix (++x) when you only need to increment. Use postfix (x++) when you need the old value first:");
AddCodeBlock(panel, @"# Prefix - increment first, then use
VAR i = 0
WHILE i < 5
    ++i    # Just incrementing
WEND

# Postfix - use old value, then increment
VAR index = 0
display.Setting = index++    # Shows 0, then index becomes 1");
```

### Add to Patterns Tab: Bit Shifting Tips

```csharp
AddSubHeader(panel, "Bit Shifting for Efficiency");
AddParagraph(panel, "Use bit shifts for power-of-2 math and flag manipulation:");
AddCodeBlock(panel, @"# Fast multiply/divide by powers of 2
x = x << 1    # Same as x * 2
x = x >> 2    # Same as x / 4

# Flag manipulation
flags = flags | (1 << bitNum)     # Set bit
flags = flags & ~(1 << bitNum)    # Clear bit
isSet = (flags >> bitNum) & 1     # Check bit");
```

---

## Summary

### Files to Update
- `UI/Services/DocumentationService.cs`

### Sections to Modify
1. `PopulateSyntax()` - Add compound assignments, increment/decrement, update bitwise operators
2. `PopulateIC10Reference()` - Add sll, srl, sra instructions
3. `GetExamples()` - Add examples 16-19
4. `PopulatePatterns()` - Add tips for new operators

### New Features Documented
- Compound Assignment: `+=`, `-=`, `*=`, `/=`
- Increment/Decrement: `++x`, `x++`, `--x`, `x--`
- Bit Shifts: `<<`, `>>`, `SHL()`, `SHR()`
- Loop Control: `BREAK`, `CONTINUE`
- IC10 Instructions: `sll`, `srl`, `sra`
